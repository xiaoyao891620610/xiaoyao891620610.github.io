<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaoyao891620610.github.io</id>
    <title>萧瑟</title>
    <updated>2021-09-24T02:49:59.481Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaoyao891620610.github.io"/>
    <link rel="self" href="https://xiaoyao891620610.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xiaoyao891620610.github.io/images/avatar.png</logo>
    <icon>https://xiaoyao891620610.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 萧瑟</rights>
    <entry>
        <title type="html"><![CDATA[HDFS]]></title>
        <id>https://xiaoyao891620610.github.io/post/hdfs/</id>
        <link href="https://xiaoyao891620610.github.io/post/hdfs/">
        </link>
        <updated>2021-09-23T02:07:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一hdfs的概念">一.HDFS的概念</h3>
<p>​	HDFS (Hadoop Distributed File System),是一个分布式文件系统，运用了分而治之的设计思想，部署在低廉的硬件上，将大文件，大批量文件，分布式存放在大量服务器上，并对海量数据进行运算分析。</p>
<pre><code>大数据系统中的作用：为各类分布式的运算框架 (mapreduce,spark,tez,.......)提供数据存储服务
</code></pre>
<h3 id="二hdfs的架构">二.HDFS的架构</h3>
<p>​	HDFS集群中包含了NameNode, SecondaryNameNode,DataNode这几个角色。</p>
<p>​		NameNode(NN)： NameNode是HDFS的主节点，主要用于维护hdfs文件系统的目录树，维护的信息是保存在本地磁盘上：命名空间镜像文件(fsimage)和编辑日志文件(edits)。并且记录这每一个块(block)所在的数据节点(DataNode)的位置(block的id，block所在的datanode服务器)。</p>
<h3 id="secondarynamenodesnn定期将编辑日志文件edits和命名空间镜像文件fsimage合并防止编辑日志文件过大同时能元数据和namenode元数据一致">SecondaryNameNode(SNN)：定期将编辑日志文件(edits)和命名空间镜像文件(fsimage)合并，防止编辑日志文件过大，同时能元数据和namenode元数据一致。</h3>
<blockquote>
<p>​		NN和SNN的工作机制</p>
</blockquote>
<p>​		<img src="https://xiaoyao891620610.github.io/post-images/1632383275847.jpg" alt="" loading="lazy"></p>
<p>​		SNN会定期询问NN是否需要checkpoint然后直接带回NN是否检查的结果，当checkpoint定时时间到了或者edits中的数据满了，SNN会请求执行checkpoint。</p>
<p>​		SNN用来完成edits和fsimage的合并，会请求namenode停止使用edits，暂时将写入操作放入一个新的文件edits.new, SecondaryNameNode通过http get请求获取edits和fsimage，同时加载到内存当中逐一进行合并操作，生成新的fsimage.ckpt。然后将fsimage.ckpt通过http post发送给namenode。namenode将fsimage.ckpt文件替换原有的fsimage,再将edits.new替换成edits,同时会更新fstime。</p>
<p>合并触发条件：</p>
<pre><code>fs.checkpoint.period: 默认是一个小时（3600s)
fs.checkpoint.size: edits达到一定大小时也会触发合并（默认64MB) 
</code></pre>
<p>​		DataNode(DN)：是hdfs文件系统的工作节点，以数据块的形式存储hdfs文件，并且定期向NameNode发送心跳信息，数据块信息，缓存数据块信息。</p>
<blockquote>
<p>​		SNN和DN的工作机制</p>
</blockquote>
<p>​		<img src="https://xiaoyao891620610.github.io/post-images/1632445946052.jpg" alt="" loading="lazy"></p>
<ul>
<li>
<p>一个数据块在datanode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。</p>
</li>
<li>
<p>DataNode启动后向namenode注册，通过后，周期性（1小时）的向namenode上报所有的块信息。</p>
</li>
<li>
<p>心跳是每3秒一次，心跳返回结果带有namenode给该datanode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个datanode的心跳，则认为该节点不可用。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA-向上转型和向下转型]]></title>
        <id>https://xiaoyao891620610.github.io/post/java-xiang-shang-zhuan-xing-he-xiang-xia-zhuan-xing/</id>
        <link href="https://xiaoyao891620610.github.io/post/java-xiang-shang-zhuan-xing-he-xiang-xia-zhuan-xing/">
        </link>
        <updated>2021-09-17T09:38:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>🤡 向上转型: 父类的引用指向子类的对象
</code></pre>
<p>一. 向上转型代码示例分析</p>
<pre><code>class Apple extends Fruit{
    @Override
    public void show() {
    	System.out.println(&quot;This is a Apple!&quot;);
    }
    public void circular(){
    	System.out.println(&quot;circular......!&quot;);
    }
}
public class Banana extends Fruit{
    @Override
    public void show() {
    	System.out.println(&quot;This is a Banana!&quot;);
    }
	public void curved(){
    	System.out.println(&quot;curved....!&quot;);
    }
}

public class MainFruitTest {
    public static void toDo(Fruit fruit){
    	fruit.show();
    }
    public static void main(String[] args) {
        //向上转型-父类的引用指向子类的对象
        Fruit apple = new Apple();
        //向下转型-把子类对象的父类引用赋给子类引用，这里是强制转换
        // Apple appleDown = (Apple)apple;
        //appleDown.circular(); // circular......!
        apple.circular(); //编译报错可以运行。运行报错-&gt;java: 找不到符号 符号:   方法 circular()  位置: 类 org.hadoop.Fruit.  注：apple虽然指向的是子类对象，但丢失了circular()方法
        toDo(apple); // This is a Apple!

        Fruit banana = new Banana();
        toDo(banana); // This is a Banana!
    }
}
</code></pre>
<p>​		Fruit apple = new Apple()，实例化的Apple对象赋值给了父类Fruit对象，这便是典型的向上转型。当向上转型之后，父类引用变量便可以访问子类中继承了(或者说属于)父类的属性和方法，但是不能访问子类独有的属性和方法（java: 找不到符号 符号:   方法 circular()  位置: 类 org.hadoop.Fruit）。</p>
<p>二. 向上转型作用</p>
<pre><code>public static void toDo(Fruit fruit){
	fruit.show();
}
</code></pre>
<p>​		以父类为参数，但是在调用的时候传的是子类的对象，方法toDo()以子类为对象，无论是Apple，还是Banana，都会向上转型成Fruit对象，这样在调用show()方法时，还是子类在调用，就不需要再重载多个toDo()方法了，这样会节约代码量，也正提现了JAVA的抽象编程思想。</p>
<pre><code>🤡向下转型：把子类对象的父类引用赋给子类引用
</code></pre>
<p>一.   向下转型的注意点</p>
<p>​		例 1 ：Fruit apple = new Apple();</p>
<p>​					Apple appleDown = (Apple)apple;</p>
<p>​					正确的向下转型，因为appleDown 指向的是子类对象。</p>
<p>​		例 2 ：Fruit fruit = new Fruit();</p>
<p>​					Apple apple = (Apple)fruit;</p>
<pre><code>运行报错：org.hadoop.Fruit cannot be cast to org.hadoop.Apple
at org.hadoop.MainFruitTest.main
</code></pre>
<p>二.  向下转型的作用</p>
<p>​	向上转型时，作为子类对象的父类引用无法调用除与父类共有的方法和属性。那么此时就可以通过向下转型，把父类作为子类的引用强制转换赋给子类的对象，这样就可以调用子类的全部方法。当然要结合实际出发去转换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络概述]]></title>
        <id>https://xiaoyao891620610.github.io/post/wang-luo-gai-shu-he-linux-xu-ni-ji-yi/</id>
        <link href="https://xiaoyao891620610.github.io/post/wang-luo-gai-shu-he-linux-xu-ni-ji-yi/">
        </link>
        <updated>2020-11-20T07:42:18.000Z</updated>
        <summary type="html"><![CDATA[<p>记录，本章是整个计算机网络的概述，后面会具体有五层协议的体系结构。</p>
<p>互联网的组成<br>
互联网的组成是非常复杂的，但是根据它的工作方式我们可以分成两部分：核心部分和边缘部分<br>
　　１. 边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。<br>
　　２. 核心部分：有大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。<br>
　　两种工作模式的示意图。<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605861195301.jpg" alt="" loading="lazy"><br>
　　<br>
<strong>互联网的边缘部分：</strong><br>
　　是连接在互联网上的所有主机，称为端系统(end system）。可以是笔记本电脑，平板，网络摄像头。拥有者可以是个人，企业，甚至是ISP。<br>
　　其它的概念型的东西不好写太多，自己记住就好了。既然是说计算机那么就要知道主机之间是怎么通信的。<br>
　　１.客户－服务器方式（Clent/Server -- C/S）原理图<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605862370955.jpg" alt="" loading="lazy"><br>
　　２．对等连接方式（Peer-to-Peer -- P2P）原理图<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605948572968.png" alt="" loading="lazy"><br>
　　其实P2P的本质还是C/S，只是对等连接中的每一台主机既是客户又是服务器。如图所示可以看出来客户在请求别的服务器的同时也提供着服务。那么这种主机的通信方式有点非常的明显，例如：<strong>快播</strong>。一个节点损坏不影响其它节点继续下载电影。我们可以通过很多的节点去下载1G的电影的小片段，最后重组在一起。所以是下载的人越多，下载的就越快，压根不存在带宽不够的情况。所以这种情况服务器得省很多钱，没必要花大价钱加带宽了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录，本章是整个计算机网络的概述，后面会具体有五层协议的体系结构。</p>
<p>互联网的组成<br>
互联网的组成是非常复杂的，但是根据它的工作方式我们可以分成两部分：核心部分和边缘部分<br>
　　１. 边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。<br>
　　２. 核心部分：有大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。<br>
　　两种工作模式的示意图。<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605861195301.jpg" alt="" loading="lazy"><br>
　　<br>
<strong>互联网的边缘部分：</strong><br>
　　是连接在互联网上的所有主机，称为端系统(end system）。可以是笔记本电脑，平板，网络摄像头。拥有者可以是个人，企业，甚至是ISP。<br>
　　其它的概念型的东西不好写太多，自己记住就好了。既然是说计算机那么就要知道主机之间是怎么通信的。<br>
　　１.客户－服务器方式（Clent/Server -- C/S）原理图<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605862370955.jpg" alt="" loading="lazy"><br>
　　２．对等连接方式（Peer-to-Peer -- P2P）原理图<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605948572968.png" alt="" loading="lazy"><br>
　　其实P2P的本质还是C/S，只是对等连接中的每一台主机既是客户又是服务器。如图所示可以看出来客户在请求别的服务器的同时也提供着服务。那么这种主机的通信方式有点非常的明显，例如：<strong>快播</strong>。一个节点损坏不影响其它节点继续下载电影。我们可以通过很多的节点去下载1G的电影的小片段，最后重组在一起。所以是下载的人越多，下载的就越快，压根不存在带宽不够的情况。所以这种情况服务器得省很多钱，没必要花大价钱加带宽了。</p>
<!-- more -->
<!-- more -->
<p><strong>互联网的核心部分：</strong><br>
　　电路交换（Circuit Switching）:例：打电话  建立连接（申请占用通信资源）-&gt;通话（一直占用通信资源）-&gt;释放连接（释放通信资源），电路交换适用于数据量很大的实时性传输：核心路由器之间可以使用电路交换。<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605948188035.jpg" alt="" loading="lazy"><br>
　　　　　　　　　　　　　　　　　　　电路交换示意图</p>
<p>​　　报文交换（Message Switcing）：报文一般比分组长的多，报文交换的时延较长<br>
​　　分组交换（Packet Switcing）：采用存储转发技术，是把一个报文拆分为几个分组后再进行传送。优点：高效，灵活，迅速，可靠  问题：时延，开销<br>
<img src="https://xiaoyao891620610.github.io/post-images/1605948123122.jpg" alt="" loading="lazy"><br>
　　　　　　　　　　　　　　　　　以分组为基本单位在网络中传输</p>
<p><img src="https://xiaoyao891620610.github.io/post-images/1605948852329.jpg" alt="" loading="lazy"><br>
　　　　　　　　　　　　　　　　　三种交换方式的比较</p>
<p>计算机网络的体系结构<br>
　　具有五层协议的体系结构：<br>
　　应用层（Application）：通过应用程序间的交互来完成特定的网络任务。应用层交互的数据单元成为报文（message）。应用层协议：HTTP,SMTP,DNS。<br>
　　运输层（Transport）：两台主机中进程之间的通信提供通用的数据传输服务。运输层主要使用两种协议，TCP协议和UDP协议。<br>
　　×传输控制协议TCP——提供面向连接的，可靠的数据传输服务，单位是报文段。<br>
　　×用户数据包协议ＵDP——提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性，单位是用户数据报。<br>
　　网络层（Network）:为分组交换网上的不同主机提供通信服务。比如IP地址选址，选择最佳路径。<br>
　　数据链路层（Data Link）： 数据如何封装  添加物理层地址（MAC地址）<br>
　　​物理层（Physical）：电压，接口标准（比如网线）<br>
<img src="https://xiaoyao891620610.github.io/post-images/1606047565974.jpg" alt="" loading="lazy"></p>
<p></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你尽力了吗? (来自中国著名网络安全专家小四scz)]]></title>
        <id>https://xiaoyao891620610.github.io/post/ni-jin-li-liao-ma-lai-zi-zhong-guo-zhu-ming-wang-luo-an-quan-zhuan-jia-xiao-si-scz/</id>
        <link href="https://xiaoyao891620610.github.io/post/ni-jin-li-liao-ma-lai-zi-zhong-guo-zhu-ming-wang-luo-an-quan-zhuan-jia-xiao-si-scz/">
        </link>
        <updated>2020-11-13T01:54:42.000Z</updated>
        <summary type="html"><![CDATA[<!-- more -->
<p>很多人问如何入门如何入门，我却不知道要问的是入什么门。 很少把某些好文章耐心从头看完，我这次就深有体会。比如袁哥的sniffer原理，一直以为自己对sniffer原理很清楚的，所以也就不曾仔细看过袁哥的这篇。后来有天晚上和袁哥讨论，如何通过端口读写直接获取mac地址，为什么antisniff可以获得真正的mac地址，而不受更改mac地址技术的影响，如何在linux下获得真正的mac地址。我一直对linux下的端口读写心存疑虑，总觉得在保护模式下的端口都做 了内存映象等等。结果袁哥问了我一句，你仔细看我写的文章没有，我楞，最近因为要印刷月刊，我整 理以前的很多文档，被迫认真过滤它们，才发现袁哥的文章让我又有新认识。再后来整理到tt的几篇缓 冲区溢出的，尤其是上面的关于Solaris可装载内核模块，那就更觉得惭愧了。 以前说书非借不能读，现在是文章留在硬盘上却不读。</p>
]]></summary>
        <content type="html"><![CDATA[<!-- more -->
<p>很多人问如何入门如何入门，我却不知道要问的是入什么门。 很少把某些好文章耐心从头看完，我这次就深有体会。比如袁哥的sniffer原理，一直以为自己对sniffer原理很清楚的，所以也就不曾仔细看过袁哥的这篇。后来有天晚上和袁哥讨论，如何通过端口读写直接获取mac地址，为什么antisniff可以获得真正的mac地址，而不受更改mac地址技术的影响，如何在linux下获得真正的mac地址。我一直对linux下的端口读写心存疑虑，总觉得在保护模式下的端口都做 了内存映象等等。结果袁哥问了我一句，你仔细看我写的文章没有，我楞，最近因为要印刷月刊，我整 理以前的很多文档，被迫认真过滤它们，才发现袁哥的文章让我又有新认识。再后来整理到tt的几篇缓 冲区溢出的，尤其是上面的关于Solaris可装载内核模块，那就更觉得惭愧了。 以前说书非借不能读，现在是文章留在硬盘上却不读。</p>
<!-- more -->
<p>其实本版已经很多经典文章了，也推荐了不少经典书籍了，有几个好好看过呢。W.Richard.Stevens的UNP我算是认真看过加了不少旁注，APUE就没有那么认真了，而卷II的一半认真看过，写过读书笔记，卷III就没有看一页。道格拉斯的卷I、卷III是认真看过几遍，卷II就只断续看过。而很多技术文章，如果搞到手了就懒得再看，却不知道这浪费了多少资源，忽略了多少资源。</p>
<!-- more -->
<p>BBS是真正能学到东西的地方吗？rain说不是的，我说也不是的。不过这里能开阔人的视野，能得到对大方向的指引，足够了。我一直都希望大家从这里学到的不是技术本身，而是学习方法和一种不再狂热的 淡然。很多技术，明天就会过时，如果你掌握的是学习方法，那你还有下一个机会，如果你掌握的仅仅是这个技术本身，你就没有机会了。</p>
<!-- more -->
<p>其实我对系统安全是真不懂，因为我一直都喜欢看程序写程序却不喜欢也没有能力攻击谁谁的主机/站点 。我所能在这里做的是，为大家提供一个方向，一种让你的狂热归于淡然的说教。如果你连&lt;&lt;Windows NT设备驱动程序编写&gt;&gt;、&lt;&lt;win9x系统编程&gt;&gt;都没有看过，却要写个什么隐藏自己的木马，搞笑。如果你 看都不看汇编语言，偏要问exploit code的原理，那我无法回答也不想回答你。总有人责问，要讨个说法纭纭，说什么提问却没有回答。不回答已经是正确的处理方式了，至少没有回你一句，看书去，对不对，至少没有扰乱版面让你生闷气。 Unix的man手册你要都看完了，想不会Unix都不行了。微软的MSDN、Platfor SDK DOC你要看完了，你想把Win编程想象得稍微困难点都找不到理由。</p>
<!-- more -->
<p>还是那句话，一个程序员做W.Richard.Stevens那个份上 ，做到逝世后还能叫全世界的顶级hacker们专门著文怀念，但生前却不曾著文攻击，想想看，那是一种什么样的境界，那是一份什么样的淡然。我们可以大肆讨论技术问题，可以就技术问题进行激烈的卓有成效的讨论，却无意进行基础知识、资源信息的版面重复。我刚在前面贴了一堆isbase的文章，开头就是主页标识，却在后面立刻问什么主页在哪里？前面刚刚讨论过如何修改mac地址，后面马上又来一个，前后相差不过3篇文章。选择沉默已经是很多朋友忍耐力的优异表现了。</p>
<!-- more -->
<p>这次sztcww问的关于socket号为什么选择4而不是3，就很有专业精神，虽然我也不清楚，但这样的问题 我就乐意代他请教tt本人，至少他认真看了文章研究过代码，而不是盲目地发问。如此讨论问题的同时 ，大家都可以提高。谁都乐意参与讨论这种问题。很多东西都是可以举一反三的。vertex的lids，被 packetstorm天天追踪更新，你要是看了THC的那三篇，觉得理解一个就理解了一堆，都是内核模块上的 手脚。你不看你怎么知道。我不想在这里陷入具体技术问题的讨论中去，你要是觉得该做点什么了，就自己去看自己去找。 没有什么人摆什么架子，也没有什么人生来就是干这个的。你自己问自己，尽力了吗？</p>
]]></content>
    </entry>
</feed>